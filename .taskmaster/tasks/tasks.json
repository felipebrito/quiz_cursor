{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Next.js Project with TypeScript and Tailwind CSS",
        "description": "Set up a new Next.js 14+ project using `create-next-app`. Configure it with TypeScript for type safety and Tailwind CSS for styling, following the project's technical architecture requirements.",
        "details": "Run `npx create-next-app@latest --typescript --tailwind --eslint`. Configure `tailwind.config.ts` and `globals.css` to establish the base styling foundation, including setting up the dark mode and primary fonts for the brutalist theme.",
        "testStrategy": "Verify that the Next.js development server runs without errors. Create a simple test page to confirm that TypeScript compilation and Tailwind CSS classes are applied correctly.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold Next.js Project with `create-next-app`",
            "description": "Initialize a new Next.js 14+ project using the `create-next-app` command-line tool with the required flags for TypeScript, Tailwind CSS, and project structure.",
            "dependencies": [],
            "details": "Run the command `npx create-next-app@latest --typescript --tailwind --eslint --app --src-dir --import-alias \"@/*\"`. This will set up the project with the App Router, a `src` directory, and pre-configured path aliases, which are standard for this project.",
            "status": "done",
            "testStrategy": "After the command completes, run `npm run dev` and ensure the default Next.js application loads in the browser at `http://localhost:3000` without any errors."
          },
          {
            "id": 2,
            "title": "Configure Tailwind CSS Theme for Brutalist Style",
            "description": "Modify the `tailwind.config.ts` file to define the color palette, fonts, and dark mode strategy required for the project's brutalist aesthetic.",
            "dependencies": [
              "1.1"
            ],
            "details": "In `tailwind.config.ts`, set `darkMode: 'class'`. Extend the `theme` object to include custom `colors` (e.g., primary, secondary, accent) and `fontFamily` for display and body text. Add any necessary plugins for animations or forms.",
            "status": "done",
            "testStrategy": "No direct test. This configuration will be verified in a later subtask when components are styled."
          },
          {
            "id": 3,
            "title": "Define Global CSS and Import Fonts",
            "description": "Update the `globals.css` file to import the necessary fonts and apply base styles to the application, including default text and background colors for both light and dark modes.",
            "dependencies": [
              "1.2"
            ],
            "details": "In `src/app/globals.css`, use `@import` to fetch the font files (e.g., from Google Fonts) defined in the Tailwind config. Apply base styles to the `body` element, setting default `background-color` and `color` for light and dark themes using Tailwind's `@apply` directive with theme variables.",
            "status": "done",
            "testStrategy": "Run the dev server and use browser developer tools to inspect the `body` element, verifying that the correct fonts are loaded and base background/text colors are applied."
          },
          {
            "id": 4,
            "title": "Clean Up Boilerplate and Organize Project Structure",
            "description": "Remove the default content generated by `create-next-app` from the main page and establish the initial folder structure for components and other project directories.",
            "dependencies": [
              "1.1"
            ],
            "details": "Clear the contents of `src/app/page.tsx` and replace it with a simple `<h1>` tag like `<h1>Quiz App</h1>`. Delete the default Next.js and Vercel SVG assets from the `/public` folder. Create empty placeholder directories: `src/components/ui`, `src/components/layout`, `src/lib`, and `src/app/api` to establish the project's architecture.",
            "status": "done",
            "testStrategy": "Navigate to the homepage and confirm that only the simple `<h1>` tag is rendered, and the default Next.js styling is gone."
          },
          {
            "id": 5,
            "title": "Create Test Component to Verify Configuration",
            "description": "Create a simple component on the main page to confirm that TypeScript is compiling correctly and that custom Tailwind CSS classes, fonts, and dark mode are being applied as expected.",
            "dependencies": [
              "1.3",
              "1.4"
            ],
            "details": "In `src/app/page.tsx`, add a `div` with a custom background color from the theme (e.g., `bg-primary`). Add a `p` tag and apply the custom primary font class (e.g., `font-display`). Add a simple button that toggles a 'dark' class on the `<html>` element to test the dark mode configuration. Run the dev server to visually inspect that all styles are applied correctly.",
            "status": "done",
            "testStrategy": "Visually confirm on the homepage that the `div` has the correct background color, the text uses the correct font, and clicking the button successfully toggles the application between light and dark themes."
          }
        ]
      },
      {
        "id": 2,
        "title": "Configure Prisma ORM with SQLite and Define Data Models",
        "description": "Integrate Prisma ORM into the project. Set up the initial database schema with SQLite for development and define all required data models: Participant, Game, GameParticipant, Question, and Answer.",
        "details": "Install Prisma CLI. Run `npx prisma init --datasource-provider sqlite`. Define the models in `prisma/schema.prisma` according to the PRD, including fields, types, and relations. Generate the initial migration with `npx prisma migrate dev --name init` and create the Prisma Client.",
        "testStrategy": "Write a simple script or unit test to connect to the database using the generated Prisma Client and perform basic CRUD operations on the Participant model to ensure the connection and schema are valid.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Prisma and Initialize Configuration",
            "description": "Add Prisma as a development dependency and run the init command to create the initial Prisma configuration files, setting SQLite as the data source.",
            "dependencies": [],
            "details": "Run `npm install prisma --save-dev`. Then, execute `npx prisma init --datasource-provider sqlite` to generate the `prisma` directory and the `schema.prisma` file. Ensure the `.env` file is updated with `DATABASE_URL=\"file:./dev.db\"`.",
            "status": "done",
            "testStrategy": "Verify that the `prisma` directory, `prisma/schema.prisma`, and `.env` files are created and correctly configured."
          },
          {
            "id": 2,
            "title": "Define Core Data Models in Prisma Schema",
            "description": "Define the `Participant`, `Game`, and `Question` models in the `prisma/schema.prisma` file. These models represent the primary entities of the quiz application.",
            "dependencies": [
              "2.1"
            ],
            "details": "In `prisma/schema.prisma`, define the `Participant` model (id, name, selfieUrl), the `Game` model (id, code, status, createdAt), and the `Question` model (id, text, options, correctAnswerIndex, imageUrl). Ensure appropriate data types are used for each field.",
            "status": "done",
            "testStrategy": "Review the schema file to ensure all required fields and types for the core models are present and correctly defined as per the project requirements."
          },
          {
            "id": 3,
            "title": "Define Relational and Join Models in Prisma Schema",
            "description": "Define the `GameParticipant` (join table) and `Answer` models in `prisma/schema.prisma` and establish the relationships between all defined models.",
            "dependencies": [
              "2.2"
            ],
            "details": "In `prisma/schema.prisma`, create the `GameParticipant` model to link `Game` and `Participant`, including a score field. Create the `Answer` model to link a `Question` and a `GameParticipant`. Add the necessary `@relation` attributes to all models to define their relationships (e.g., one-to-many, many-to-many).",
            "status": "done",
            "testStrategy": "Run `npx prisma validate` to check for syntax errors and ensure all relations are correctly defined without ambiguity."
          },
          {
            "id": 4,
            "title": "Generate Initial Database Migration and Prisma Client",
            "description": "Create the first database migration based on the complete schema and generate the Prisma Client for database access.",
            "dependencies": [
              "2.3"
            ],
            "details": "Run the command `npx prisma migrate dev --name init`. This will create the SQLite database file (`dev.db`), create a new migration file in `prisma/migrations`, apply the schema to the database, and generate the type-safe Prisma Client in `node_modules/@prisma/client`.",
            "status": "done",
            "testStrategy": "Confirm that the `prisma/migrations` directory contains a new folder with the `migration.sql` file. Check for the existence of the `dev.db` file. The command should complete without errors."
          },
          {
            "id": 5,
            "title": "Create Prisma Client Utility and Connection Validation Script",
            "description": "Implement a singleton pattern for the Prisma Client instance and create a simple script to test the database connection by performing a basic CRUD operation on the Participant model.",
            "dependencies": [
              "2.4"
            ],
            "details": "Create a file at `lib/prisma.ts` that instantiates and exports a single Prisma Client instance, preventing multiple connections in a serverless environment. Create a temporary test script (e.g., `scripts/test-db.ts`) that imports the client, creates a new participant, reads it back, and then deletes it to confirm the entire setup is functional.",
            "status": "done",
            "testStrategy": "Execute the test script (e.g., `npx ts-node scripts/test-db.ts`) and verify that it runs without errors and logs the created participant's data to the console."
          }
        ]
      },
      {
        "id": 3,
        "title": "Integrate shadcn/ui and Create Base Layout",
        "description": "Set up shadcn/ui for the component library. Create a main layout component that will be shared across different pages (Totem, Admin, Game Display) and includes basic structure and styling.",
        "details": "Use the `shadcn-ui` CLI to initialize the library into the project. Create a `components/layout/MainLayout.tsx` component. Add a few core components like `Button` and `Card` to verify the setup.",
        "testStrategy": "Create a storybook story or a test page that renders the MainLayout and several shadcn/ui components to visually confirm they are styled and functioning as expected.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize shadcn/ui using the CLI",
            "description": "Run the shadcn-ui init command to set up the necessary configuration files and dependencies. This will create `components.json` and modify `tailwind.config.ts` and `globals.css`.",
            "dependencies": [],
            "details": "Execute `npx shadcn-ui@latest init` in the project root. When prompted, confirm the use of TypeScript, select the 'Default' style, and use the existing `tailwind.config.ts` and `src/app/globals.css` files. Set up path aliases: `@/components` for components and `@/lib` for utils.",
            "status": "done",
            "testStrategy": "Verify that a `components.json` file is created in the project root and that `tailwind.config.ts` and `src/app/globals.css` have been updated with shadcn/ui's base configuration and CSS variables."
          },
          {
            "id": 2,
            "title": "Add Core UI Components (Button, Card) via CLI",
            "description": "Use the shadcn-ui CLI to add the `Button` and `Card` components to the project. This will populate the `src/components/ui` directory and serve as a first test of the setup.",
            "dependencies": [
              "3.1"
            ],
            "details": "Run the command `npx shadcn-ui@latest add button card`. This will create the files `src/components/ui/button.tsx` and `src/components/ui/card.tsx`.",
            "status": "done",
            "testStrategy": "Check for the existence and content of `src/components/ui/button.tsx` and `src/components/ui/card.tsx` to ensure they were created correctly."
          },
          {
            "id": 3,
            "title": "Create the MainLayout Component Structure",
            "description": "Create the `MainLayout.tsx` component file that will serve as the shared layout for different parts of the application. It should define the basic page structure.",
            "dependencies": [
              "3.1"
            ],
            "details": "Create a new file at `src/components/layout/MainLayout.tsx`. The component should accept `children: React.ReactNode` as a prop. The root element should be a `<main>` tag with appropriate Tailwind classes for a full-height, centered layout, e.g., `className=\"flex min-h-screen flex-col items-center justify-center p-4 bg-background\"`.",
            "status": "done",
            "testStrategy": "The component should render without errors and correctly pass through any child elements provided to it."
          },
          {
            "id": 4,
            "title": "Integrate MainLayout into the Home Page",
            "description": "Modify the main application page (`page.tsx`) to use the newly created `MainLayout` component. This will act as a test page to verify the layout and component styling.",
            "dependencies": [
              "3.3"
            ],
            "details": "Open `src/app/page.tsx`. Import the `MainLayout` component from `_@/components/layout/MainLayout_`. Wrap the existing content of the page's return statement with the `<MainLayout>` component.",
            "status": "done",
            "testStrategy": "Run the development server (`npm run dev`) and navigate to the home page. The page should now have the basic background color and layout structure defined in `MainLayout`."
          },
          {
            "id": 5,
            "title": "Verify Setup by Displaying shadcn/ui Components on Home Page",
            "description": "Add the `Button` and `Card` components to the home page to visually confirm that shadcn/ui is fully integrated and styled correctly.",
            "dependencies": [
              "3.2",
              "3.4"
            ],
            "details": "In `src/app/page.tsx`, import `Button` from `@/components/ui/button` and `Card`, `CardHeader`, `CardTitle`, `CardContent` from `@/components/ui/card`. Render a `<Card>` with a `<CardHeader>` and some text content, and also render a `<Button>`. Example: `<Button>Click me</Button>`.",
            "status": "done",
            "testStrategy": "Load the home page in a browser. Visually confirm that the Button and Card components are rendered with the default shadcn/ui styling, proving that the styles are being applied correctly through Tailwind CSS."
          }
        ]
      },
      {
        "id": 4,
        "title": "Develop Totem UI for Participant Registration",
        "description": "Create the frontend for the automated registration totem. This includes a touch-friendly form for capturing Name, City, and State.",
        "details": "Create a new page route at `/totem/register`. Use `shadcn/ui` components like `Input`, `Label`, and `Button` to build the form. Ensure the layout is simple, with large, easily tappable elements suitable for a totem interface.",
        "testStrategy": "Use a component testing library like Vitest or Jest with React Testing Library to test form inputs and submission behavior. Manually test the UI on a touch device or browser dev tools to ensure touch-friendliness.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Route and Page File for Totem Registration",
            "description": "Set up the file and routing structure for the new totem registration page within the Next.js App Router.",
            "dependencies": [],
            "details": "Create a new file at `src/app/totem/register/page.tsx`. This file will serve the `/totem/register` route. Add the `'use client';` directive at the top, as this page will contain interactive form elements. Create a basic React component shell for the registration page.",
            "status": "done",
            "testStrategy": "Run the development server and navigate to `http://localhost:3000/totem/register` to verify that the new page renders without errors."
          },
          {
            "id": 2,
            "title": "Scaffold Static Registration Form UI with shadcn/ui",
            "description": "Build the visual structure of the registration form using pre-existing shadcn/ui components, without implementing state or logic.",
            "dependencies": [
              "4.1"
            ],
            "details": "In `src/app/totem/register/page.tsx`, import and use `Input`, `Label`, and `Button` from `src/components/ui`. Lay out a form with fields for 'Name', 'City', and 'State'. Use a simple, centered layout. The form should not be functional at this stage.",
            "status": "done",
            "testStrategy": "Visually inspect the `/totem/register` page to ensure the form fields and a submit button are rendered correctly."
          },
          {
            "id": 3,
            "title": "Implement Form State Management and Validation",
            "description": "Integrate a form management library to handle user input, state changes, and validation for the registration fields.",
            "dependencies": [
              "4.2"
            ],
            "details": "Install and configure `react-hook-form` and `zod`. Create a `zod` schema to define validation rules: Name, City, and State must be non-empty strings. Connect the `Input` components to `react-hook-form` using its `register` function and display validation errors if a field is left blank.",
            "status": "done",
            "testStrategy": "Write a component test to verify that the form correctly identifies valid and invalid input based on the Zod schema. Manually test that error messages appear when submitting an empty form."
          },
          {
            "id": 4,
            "title": "Implement Form Submission Logic",
            "description": "Create the function to handle form submission, sending the captured data to the backend API.",
            "dependencies": [
              "4.3"
            ],
            "details": "Create an `onSubmit` function that will be triggered by `react-hook-form`. This function should make a `POST` request to a new (to-be-created) API endpoint, `/api/participants`, sending the form data (name, city, state) as the JSON payload. Implement logic to handle the UI state during submission (e.g., disabling the button) and after (e.g., showing a success message and clearing the form).",
            "status": "done",
            "testStrategy": "Use a tool like `msw` (Mock Service Worker) in tests to mock the `/api/participants` endpoint. Verify that a `POST` request is sent with the correct payload upon form submission. Manually test the end-to-end flow and check the browser's network tab."
          },
          {
            "id": 5,
            "title": "Apply Totem-Specific Styling for Touch-Friendliness",
            "description": "Adjust the form's styling to be suitable for a large touch-screen interface, focusing on size and spacing.",
            "dependencies": [
              "4.2"
            ],
            "details": "Using Tailwind CSS utility classes, modify the components in `src/app/totem/register/page.tsx`. Increase the font size of `Label` and `Input` components (e.g., `text-2xl`). Set the `Button` size to `lg` and add significant padding (`p-8` or similar). Ensure the overall form container is centered and has large margins for a clean, focused appearance.",
            "status": "done",
            "testStrategy": "Use browser developer tools to simulate a touch device. Manually test the page by tapping on inputs and the button to ensure they are large and easy to interact with. Verify the layout looks clean on a large viewport."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Webcam Capture for Participant Selfie",
        "description": "Integrate a webcam component into the totem registration page to allow participants to take a selfie. The captured image should be prepared for upload.",
        "details": "Use a library like `react-webcam` to display the camera feed. Implement controls for 'Take Picture' and 'Retake'. The captured image should be stored in component state as a base64 string or Blob, ready to be sent to the backend.",
        "testStrategy": "Test the component on different browsers (Chrome, Firefox) to ensure WebRTC API compatibility. Verify that a picture can be captured and its data is correctly formatted. Handle cases where camera access is denied by the user.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install react-webcam and Define Component Structure",
            "description": "Add the `react-webcam` library to the project's dependencies. Create a new file for the webcam component, `src/components/custom/WebcamCapture.tsx`, and set up the basic component structure.",
            "dependencies": [],
            "details": "Run `npm install react-webcam` or the equivalent for your package manager. Create the file `src/components/custom/WebcamCapture.tsx` with a basic React functional component boilerplate. This component will eventually encapsulate all webcam-related logic.",
            "status": "done",
            "testStrategy": "Verify that the `react-webcam` package is listed in `package.json`. Ensure the new component file is created in the correct directory and can be imported without errors."
          },
          {
            "id": 2,
            "title": "Display Live Camera Feed",
            "description": "In the `WebcamCapture.tsx` component, use the `<Webcam />` component from `react-webcam` to display the user's live camera feed. Handle the case where camera access is denied by the user.",
            "dependencies": [
              "5.1"
            ],
            "details": "Import `Webcam` from `react-webcam`. Add it to the component's render output. Use a `videoConstraints` prop to set a desired aspect ratio (e.g., 1:1 for a square selfie). Implement basic error handling to display a message if the camera is not available or permission is denied.",
            "status": "done",
            "testStrategy": "Render the component on a test page. Confirm that the browser prompts for camera access. Verify that the live video feed is displayed correctly. Test the scenario where camera access is denied and ensure a fallback message is shown."
          },
          {
            "id": 3,
            "title": "Implement 'Take Picture' Functionality",
            "description": "Add a 'Take Picture' button to the `WebcamCapture` component. When clicked, capture the current frame from the webcam feed and store it as a base64 string in the component's state.",
            "dependencies": [
              "5.2"
            ],
            "details": "Use a `useRef` to get access to the `Webcam` component's methods. Create a state variable, e.g., `const [imageSrc, setImageSrc] = useState(null)`. The 'Take Picture' button's `onClick` handler will call the `getScreenshot()` method on the webcam ref and update the `imageSrc` state with the returned base64 string.",
            "status": "done",
            "testStrategy": "Click the 'Take Picture' button and use React DevTools to inspect the component's state, verifying that `imageSrc` is populated with a valid base64 string."
          },
          {
            "id": 4,
            "title": "Implement UI for Image Preview and 'Retake' Option",
            "description": "Conditionally render the UI based on whether a picture has been taken. If no picture is taken, show the live feed and 'Take Picture' button. If a picture exists, show the captured image (`<img>` tag) along with a 'Retake' button.",
            "dependencies": [
              "5.3"
            ],
            "details": "Use the `imageSrc` state to control the UI. When `imageSrc` is null, render the `<Webcam>` component and the 'Take Picture' button. When `imageSrc` has a value, render an `<img src={imageSrc} />` and a 'Retake' button. The 'Retake' button's `onClick` handler should reset the `imageSrc` state back to null.",
            "status": "done",
            "testStrategy": "Verify the initial state shows the live feed. After taking a picture, confirm the UI switches to show the static image and the 'Retake' button. Click 'Retake' and ensure the UI reverts to the live feed."
          },
          {
            "id": 5,
            "title": "Integrate WebcamCapture into Totem Registration Page",
            "description": "Import and place the `WebcamCapture` component into the totem registration page (`src/app/totem/register/page.tsx`). Pass the captured image data from the child component to the parent registration form's state.",
            "dependencies": [
              "5.4"
            ],
            "details": "Modify the `WebcamCapture` component to accept an `onCapture` callback prop. When a picture is taken, call this function with the base64 image data. In the `TotemRegisterPage`, manage a state for the selfie and pass a handler function to the `WebcamCapture` component's `onCapture` prop to update this state. This ensures the image data is available for submission with the rest of the form.",
            "status": "done",
            "testStrategy": "On the registration page, take a selfie. Use React DevTools to confirm that the parent page's state is updated with the base64 string. Ensure the rest of the form remains interactive."
          }
        ]
      },
      {
        "id": 6,
        "title": "Create API Endpoint for Participant Creation",
        "description": "Build a Next.js API route to handle the creation of new participants. The endpoint should accept form data and the selfie image, save it to the database, and handle image storage.",
        "details": "Create an API route at `/api/participants`. The `POST` handler will parse the multipart/form-data, upload the photo to a local `/public/uploads` directory (or a cloud service), and use Prisma Client to create a new `Participant` record with `status: 'eligible'`.",
        "testStrategy": "Use an API testing tool like Postman or Insomnia to send `POST` requests to the endpoint with mock data and an image file. Verify that a 201 status code is returned and the participant is correctly saved in the SQLite database.",
        "priority": "high",
        "dependencies": [
          2,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create API Route File and POST Handler Skeleton",
            "description": "Create the necessary directory structure and file for the new API endpoint. Define an empty `POST` function to serve as the foundation for the participant creation logic.",
            "dependencies": [],
            "details": "Create the file at `app/api/participants/route.ts`. Inside this file, import `NextRequest` and `NextResponse` from `next/server` and export an async function named `POST(request: NextRequest)` that currently returns a placeholder JSON response.",
            "status": "done",
            "testStrategy": "Start the development server and use an API client like Postman or Insomnia to send a POST request to `/api/participants`. Verify that the placeholder response is returned with a 200 status code."
          },
          {
            "id": 2,
            "title": "Implement Multipart/Form-Data Parsing",
            "description": "Update the `POST` handler to parse the incoming `multipart/form-data` request to extract the participant's name and the selfie image file.",
            "dependencies": [
              "6.1"
            ],
            "details": "Inside the `POST` function in `app/api/participants/route.ts`, use `await request.formData()` to get the form data. Extract the 'name' text field and the 'selfie' file object from the `FormData` instance. Add basic validation to ensure both fields are present.",
            "status": "done",
            "testStrategy": "Add `console.log` statements for the extracted name and file details. Send a test request with a name and a file using an API client. Check the server console to confirm the data is being received and parsed correctly."
          },
          {
            "id": 3,
            "title": "Implement Selfie Image File Storage",
            "description": "Write the logic to save the parsed selfie image to the local filesystem in the `/public/uploads` directory.",
            "dependencies": [
              "6.2"
            ],
            "details": "Import `path` and `fs/promises` modules. Create the `/public/uploads` directory if it doesn't exist. Generate a unique filename for the selfie (e.g., using a timestamp or UUID) to prevent overwrites. Convert the file to a Buffer and write it to the filesystem at `public/uploads/<unique-filename>.jpg`. The resulting public URL will be `/uploads/<unique-filename>.jpg`.",
            "status": "done",
            "testStrategy": "After sending a test request, check the `/public/uploads` directory in your project to ensure the image file has been created with a unique name. Verify you can access the image in your browser at `http://localhost:3000/uploads/<filename>`."
          },
          {
            "id": 4,
            "title": "Create Participant Record using Prisma",
            "description": "Use the Prisma client to insert a new participant record into the database with the data obtained from the previous steps.",
            "dependencies": [
              "6.2",
              "6.3"
            ],
            "details": "Import the `prisma` client instance from `lib/prisma.ts`. After successfully saving the image, call `prisma.participant.create()` with the participant's name, the public URL of the saved selfie for the `selfieUrl` field, and set the `status` field to `'eligible'`. The `prisma/schema.prisma` file confirms these fields are required.",
            "status": "done",
            "testStrategy": "Use a database client (like Prisma Studio) to inspect the `Participant` table in your SQLite database. Verify that a new row is added with the correct `name`, `selfieUrl`, and `status` after a successful API request."
          },
          {
            "id": 5,
            "title": "Implement Success/Error Responses and Finalize Endpoint",
            "description": "Finalize the API endpoint by implementing proper success and error responses, including wrapping the logic in a try/catch block.",
            "dependencies": [
              "6.4"
            ],
            "details": "Wrap the file handling and database logic in a `try...catch` block. On success, return a `NextResponse.json()` with the newly created participant data and a `status: 201`. In the `catch` block, handle potential errors (e.g., validation, file system, database errors) by returning an appropriate error message and a 400 or 500 status code.",
            "status": "done",
            "testStrategy": "Test the success case by sending a valid request and verifying the 201 response and data. Test failure cases by sending a request without a name or file and verifying a 400 error. Test another failure case by, for example, making the uploads directory read-only to trigger a file system error and verifying a 500 response."
          }
        ]
      },
      {
        "id": 7,
        "title": "Develop Admin Dashboard for Participant Queue",
        "description": "Create the admin dashboard UI to display a real-time queue of registered participants who are eligible to play. The dashboard should allow for viewing participant details.",
        "details": "Create a new page at `/admin`. Fetch data from `/api/participants` to display a list of users with `status: 'eligible'`. Use the `shadcn/ui` Table component to show participant name, city, state, and photo. Implement polling or SWR for automatic refreshing.",
        "testStrategy": "Manually test the flow: register a new participant via the totem UI and verify they appear in the admin dashboard queue. Write a component test to ensure the table renders correctly with mock data.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Admin Page Route and Basic Layout",
            "description": "Create the new page route for the admin dashboard at `/admin`. This includes creating the `app/admin/page.tsx` file and setting up a basic page structure with a main heading like 'Participant Queue'.",
            "dependencies": [],
            "details": "Create a new directory `app/admin` and a `page.tsx` file inside it. The component should export a default function `AdminPage` that renders a main container with an `<h1>` or `<h2>` title. This sets up the foundational page for the dashboard.",
            "status": "done",
            "testStrategy": "Run the development server and navigate to `/admin` to ensure the page loads correctly and displays the title."
          },
          {
            "id": 2,
            "title": "Define Participant Type and Implement Data Fetching Hook",
            "description": "Install the `swr` library and create a custom hook to fetch eligible participants. Define a TypeScript type for the participant data based on the database schema.",
            "dependencies": [],
            "details": "Run `npm install swr`. Create a new file for types, e.g., `src/lib/types.ts`, and define a `Participant` type matching the fields from `lib/db/schema.ts` (id, name, city, state, photoUrl, status). Create a custom hook, e.g., `useParticipantsQueue` in `src/hooks/use-participants.ts`, that uses SWR to fetch data from `/api/participants?status=eligible`. The hook should handle loading and error states.",
            "status": "done",
            "testStrategy": "Temporarily use the hook in the `AdminPage` component and log the output to the console to verify that data is being fetched correctly."
          },
          {
            "id": 3,
            "title": "Define Table Columns for Participant Queue",
            "description": "Create the column definitions for the participant table using `tanstack/react-table`'s `ColumnDef` type. This will specify the headers and cell rendering for each column.",
            "dependencies": [
              "7.2"
            ],
            "details": "Create a new file `app/admin/columns.tsx`. Import `ColumnDef` from `tanstack/react-table` and the `Participant` type. Define and export a `columns` array. The columns should be: Photo (using `Avatar` component from `shadcn/ui`), Name, City, and State. The `accessorKey` for each column should match the property names from the `Participant` type.",
            "status": "done",
            "testStrategy": "This is a definition file. Its correctness will be verified in the next subtask when it's used to render the table. A component test could be written to render a single row with mock data and columns."
          },
          {
            "id": 4,
            "title": "Implement a Reusable DataTable Component",
            "description": "Create a generic `DataTable` component that can render data using the `shadcn/ui` Table component and `tanstack/react-table` logic.",
            "dependencies": [
              "7.3"
            ],
            "details": "Create a new component file, e.g., `app/admin/data-table.tsx`. This component will accept `columns` and `data` as props. It should use the `useReactTable` hook to initialize the table instance and render the `Table`, `TableHeader`, `TableRow`, `TableHead`, `TableBody`, and `TableCell` components from `shadcn/ui`. This follows the standard pattern for creating tables with `shadcn/ui`.",
            "status": "done",
            "testStrategy": "Create a Storybook story or a simple component test that passes mock columns and data to the `DataTable` to ensure it renders correctly."
          },
          {
            "id": 5,
            "title": "Integrate Data Fetching and DataTable on Admin Page",
            "description": "Combine the data fetching hook and the `DataTable` component on the admin page to display the live participant queue.",
            "dependencies": [
              "7.1",
              "7.2",
              "7.4"
            ],
            "details": "In `app/admin/page.tsx`, call the `useParticipantsQueue` hook to get the participant data, loading, and error states. Conditionally render a loading indicator (e.g., `Skeleton` component) or an error message. If data is available, pass it and the `columns` definition from `app/admin/columns.tsx` to the `DataTable` component.",
            "status": "done",
            "testStrategy": "Manually test the entire flow. Register a new user via the totem UI and verify they appear in the admin queue automatically due to SWR's revalidation. Check that loading and empty states are handled correctly."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Game Management in Admin Dashboard",
        "description": "Add functionality to the admin dashboard for selecting 3 participants from the queue and initiating a new game with a single click.",
        "details": "Add checkboxes to the participant table in the admin UI. Implement a 'Start Game' button that becomes active when exactly 3 participants are selected. Clicking the button should trigger a backend event to create a new `Game` and `GameParticipant` records.",
        "testStrategy": "Test the UI logic to ensure the 'Start Game' button is enabled/disabled correctly. On click, verify that a request is sent to the backend and that the database is updated with the new game and its associated participants.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Selection Checkboxes to the Admin Participant Table",
            "description": "Modify the participant data table component in the admin dashboard to include a checkbox in each row, allowing for participant selection. This will likely involve updating the column definitions for the `@tanstack/react-table` instance.",
            "dependencies": [],
            "details": "Locate the component responsible for rendering the participant list (e.g., `src/components/admin/participant-table.tsx`). Using the `@tanstack/react-table` documentation, add a new column definition for selection. This column should render a `Checkbox` component from `shadcn/ui`. Enable the `enableRowSelection` feature on the table instance.",
            "status": "pending",
            "testStrategy": "Verify in the UI that a checkbox appears on each row of the participant table and in the table header for select-all functionality. Ensure clicking the checkboxes does not cause any console errors."
          },
          {
            "id": 2,
            "title": "Implement State Management for Participant Selection",
            "description": "Introduce state management within the admin dashboard page to track which participants are currently selected. The state should hold an array of the selected participant IDs.",
            "dependencies": [
              "8.1"
            ],
            "details": "In the main admin page component (e.g., `src/app/admin/page.tsx`), use a React state hook (e.g., `useState`) to manage an object or array of selected row IDs. Pass the state and the state setter function to the participant table component to control the row selection feature implemented in the previous subtask.",
            "status": "pending",
            "testStrategy": "Use React DevTools to inspect the component state. Confirm that as checkboxes are toggled in the UI, the corresponding participant IDs are correctly added to or removed from the state array."
          },
          {
            "id": 3,
            "title": "Implement 'Start Game' Button with Conditional Logic",
            "description": "Add a 'Start Game' button to the admin dashboard UI. This button's 'disabled' attribute should be dynamically controlled based on the number of selected participants, becoming active only when exactly 3 are selected.",
            "dependencies": [
              "8.2"
            ],
            "details": "Add a `Button` component from `shadcn/ui` to the admin page. Bind its `disabled` property to a condition that checks if the length of the selected participants state array is not equal to 3. This ensures the button is only clickable when the condition for starting a game is met.",
            "status": "pending",
            "testStrategy": "Manually test the UI. The 'Start Game' button should be disabled by default. It should remain disabled when 1, 2, 4, or more participants are selected. Verify it becomes enabled only when exactly 3 participants are selected."
          },
          {
            "id": 4,
            "title": "Create Backend API Endpoint for Game Creation",
            "description": "Develop a new API route (`POST /api/game/start`) that accepts an array of three participant IDs. This endpoint will be responsible for initiating the game creation process.",
            "dependencies": [],
            "details": "Create a new Next.js API route file at `src/app/api/game/start/route.ts`. Implement a `POST` request handler that parses the incoming JSON body to extract an array of `participantIds`. Add validation to ensure the request body contains an array with exactly three string IDs. Return an appropriate error response if the validation fails.",
            "status": "pending",
            "testStrategy": "Use a tool like Postman or `curl` to send POST requests to the `/api/game/start` endpoint. Test with invalid payloads (e.g., no body, incorrect data type, array with more or less than 3 IDs) and verify that it returns a 400 Bad Request status. Send a valid payload and expect a success response (e.g., 201 Created)."
          },
          {
            "id": 5,
            "title": "Implement Database Logic to Create Game and Participant Records",
            "description": "Within the new API endpoint, use Prisma to create a new `Game` record and its corresponding `GameParticipant` records in a single, atomic database transaction.",
            "dependencies": [
              "8.3",
              "8.4"
            ],
            "details": "In the `POST` handler for `/api/game/start`, use the `prisma.$transaction` API. The transaction should first create a new record in the `Game` table. Then, using the ID of the newly created game, create three new records in the `GameParticipant` table, one for each participant ID received in the request. On the client-side, wire the 'Start Game' button's `onClick` event to call this API endpoint, passing the selected participant IDs.",
            "status": "pending",
            "testStrategy": "After a successful API call from the UI or an API client, query the database directly or via a Prisma Client script. Verify that a new row exists in the `Game` table and that three new rows exist in the `GameParticipant` table, all correctly linked to the new game ID and the respective participant IDs."
          }
        ]
      },
      {
        "id": 9,
        "title": "Set Up Socket.IO Server for Real-time Communication",
        "description": "Integrate Socket.IO into the Next.js application to manage real-time events between the server, players, and public display.",
        "details": "Create a custom server file or use an API route to initialize the Socket.IO server and attach it to the Next.js HTTP server. Define a basic connection handler and a namespace for game events (e.g., `/game`).",
        "testStrategy": "Create a simple client-side script to connect to the Socket.IO server. Test sending and receiving a basic 'ping'/'pong' event to confirm the real-time connection is established.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Socket.IO Dependencies and Update Scripts",
            "description": "Add `socket.io` and `socket.io-client` to the project dependencies. Update the `dev`, `build`, and `start` scripts in `package.json` to use a custom server file.",
            "dependencies": [],
            "details": "Run `npm install socket.io socket.io-client`. Then, modify the `scripts` section in `package.json`. The `dev` script should run `node server.ts` (using `ts-node` or similar for development), and the `start` script should run `node .next/server.js` after the build.",
            "status": "pending",
            "testStrategy": "Verify that the new dependencies are listed in `package.json` and `package-lock.json`. Confirm that `npm run dev` attempts to run the (not yet created) server file without crashing immediately due to script errors."
          },
          {
            "id": 2,
            "title": "Create Custom Server and Initialize Socket.IO",
            "description": "Create a new `server.ts` file in the project root. This file will set up an HTTP server and attach a new Socket.IO server instance to it.",
            "dependencies": [
              "9.1"
            ],
            "details": "In `server.ts`, import `http` and `Server` from `socket.io`. Create an HTTP server instance. Instantiate the Socket.IO `Server`, passing the HTTP server instance. The Socket.IO server should be exported or stored in a way that it can be accessed by other parts of the server logic. The server should listen on a port, e.g., 3000.",
            "status": "pending",
            "testStrategy": "Run the `server.ts` file directly with `ts-node`. Check the console output to ensure the server starts and logs a message indicating it's listening on the specified port without errors."
          },
          {
            "id": 3,
            "title": "Integrate Next.js Request Handler into Custom Server",
            "description": "Modify `server.ts` to also handle requests for the Next.js application, effectively proxying them to the Next.js handler.",
            "dependencies": [
              "9.2"
            ],
            "details": "In `server.ts`, import `next`. Create a Next.js app instance with `dev` mode detection (`const dev = process.env.NODE_ENV !== 'production'`). After the app is prepared (`app.prepare()`), use the app's request handler (`app.getRequestHandler()`) as the main handler for the HTTP server.",
            "status": "pending",
            "testStrategy": "Run `npm run dev`. Open a browser and navigate to `http://localhost:3000`. The default Next.js homepage should render correctly, proving that the custom server is successfully serving the Next.js application."
          },
          {
            "id": 4,
            "title": "Define `/game` Namespace and Connection Handler",
            "description": "In the server-side Socket.IO setup, define a specific namespace for all game-related events called `/game` and add a basic connection listener.",
            "dependencies": [
              "9.2"
            ],
            "details": "In `server.ts`, after initializing the Socket.IO server, create a namespace using `io.of('/game')`. Attach a `connection` event listener to this namespace. Inside the listener, log a message to the console with the connected `socket.id` to confirm new clients are connecting to the correct namespace.",
            "status": "pending",
            "testStrategy": "After implementing the client-side connection in the next subtask, check the server console logs for the 'New client connected to /game' message when a client attempts to connect."
          },
          {
            "id": 5,
            "title": "Create Client-side Socket Hook and Test Connection",
            "description": "Create a React hook (`useSocket`) or a context provider to manage the client-side Socket.IO connection. Use this hook on a test page to verify the connection and event handling.",
            "dependencies": [
              "9.4"
            ],
            "details": "Create a new file, e.g., `src/hooks/useSocket.ts`. This hook will initialize a `socket.io-client` connection to the `/game` namespace. It should handle connection, disconnection, and cleanup logic within a `useEffect`. Create a temporary test page that uses this hook and implements a button to emit a `ping` event. The server should listen for `ping` and respond with `pong`, which the client logs to the console.",
            "status": "pending",
            "testStrategy": "Load the test page in the browser. Verify the server logs a new connection. Click the 'ping' button and check the browser's developer console for the 'pong' event received from the server. This confirms the full real-time communication loop is working."
          }
        ]
      },
      {
        "id": 10,
        "title": "Develop Backend Game State Machine and Logic",
        "description": "Implement the core server-side logic for managing the game flow, including rounds, question sequencing, timing, and scoring.",
        "details": "Create a class or module to manage the state of each game. This machine will be triggered by the 'Start Game' event. It will handle loading questions (initially hardcoded), advancing through 8 rounds, managing timers for each question, and calculating scores based on correctness and response time.",
        "testStrategy": "Write unit tests for the game state machine. Test transitions between states (e.g., `waiting` -> `in_progress` -> `finished`), round progression, and score calculation logic with various inputs.",
        "priority": "high",
        "dependencies": [
          2,
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Core Game State Manager Class",
            "description": "Define a `GameManager` class in a new file, such as `src/server/game/GameManager.ts`. This class will be responsible for managing the state of a single game instance and will serve as the foundation for the game logic.",
            "dependencies": [],
            "details": "The class constructor should accept a `gameId` and an array of `participants`. It needs to initialize the internal state, including `status: 'starting'`, `currentRound: 0`, and a `scores` object or map keyed by participant ID. Create a placeholder `start()` method that will be used to kick off the game flow. This class will be instantiated in the 'Start Game' API route.",
            "status": "pending",
            "testStrategy": "Write a unit test to verify that the `GameManager` class can be instantiated correctly and that its initial state (status, round, scores) is set as expected based on the constructor arguments."
          },
          {
            "id": 2,
            "title": "Implement Question Loading and Round Start Logic",
            "description": "Add functionality to the `GameManager` to load questions and initiate the first round of the game. This involves managing the transition from a waiting state to an active round.",
            "dependencies": [
              "10.1"
            ],
            "details": "Create a file `src/server/game/questions.ts` to store a hardcoded array of 8 question objects. Each object should have an `id`, `text`, `options`, and `correctAnswerIndex`. In `GameManager`, implement a `startNextRound` method. This method should increment the round counter, retrieve the current question from the hardcoded array, update the game status to `round_in_progress`, and emit a `new_round` WebSocket event to the game's participants. The event payload must include the round number, question text, and answer options.",
            "status": "pending",
            "testStrategy": "Test the `startNextRound` method. Verify that it correctly updates the internal state (`currentRound`, `status`) and that it attempts to emit a `new_round` event with the correct question data for round 1."
          },
          {
            "id": 3,
            "title": "Implement Server-Side Question Timer",
            "description": "Integrate a server-side timer into the `GameManager` to enforce a time limit for answering each question. This ensures the game progresses even if players don't respond.",
            "dependencies": [
              "10.2"
            ],
            "details": "Within the `startNextRound` method, use `setTimeout` to create a timer (e.g., 15 seconds). Store the timer reference so it can be cleared if needed. When the timer expires, it should trigger a new method, `endRound`, which changes the game status to `round_over` and emits a `time_up` WebSocket event to all clients in the game. This will signal the clients to stop accepting input.",
            "status": "pending",
            "testStrategy": "Using a mock timer (e.g., `jest.useFakeTimers`), test that after `startNextRound` is called, advancing the timer by the specified duration correctly calls the `endRound` method and updates the game status."
          },
          {
            "id": 4,
            "title": "Implement Answer Submission and Scoring Logic",
            "description": "Develop the logic to process answers submitted by players, validate them, and calculate scores based on correctness and response time.",
            "dependencies": [
              "10.3"
            ],
            "details": "Create a public method `handleAnswer(participantId, answerIndex, timestamp)` in the `GameManager`. This method will be invoked by a WebSocket event listener. It must check if the game status is `round_in_progress`. If so, it should verify the `answerIndex` against the correct answer for the current round. Calculate the score: grant a base number of points for a correct answer, plus bonus points based on how quickly the answer was submitted (e.g., `score = 100 + (15 - timeElapsed) * 10`). Update the participant's score in the internal state.",
            "status": "pending",
            "testStrategy": "Write unit tests for the `handleAnswer` method. Test various scenarios: correct answer early, correct answer late, incorrect answer, and an answer submitted after the timer has expired. Verify the score calculation is correct in each valid case."
          },
          {
            "id": 5,
            "title": "Implement Round Progression and Game Completion",
            "description": "Finalize the game loop by implementing the logic to transition between rounds and to properly conclude the game after the final round.",
            "dependencies": [
              "10.4"
            ],
            "details": "In the `endRound` method (triggered by the timer), after emitting `time_up`, emit a `round_result` event containing the correct answer and the updated leaderboard. Then, after a short delay (e.g., 3-5 seconds using another `setTimeout`), check if `currentRound` is less than 8. If it is, call `startNextRound()` to proceed. If it's the final round, change the game status to `finished`, update the `Game` model's status in the database, and emit a `game_over` event with the final scores and winner.",
            "status": "pending",
            "testStrategy": "Test the end-to-end flow for a mini-game of 2 rounds. Verify that after the first round ends, the `startNextRound` method is called for the second round. After the second round ends, verify that the game status is set to `finished` and the `game_over` event is triggered."
          }
        ]
      },
      {
        "id": 11,
        "title": "Create Player Game Screen UI",
        "description": "Build the user interface for the players participating in the quiz. The screen should display the current question, multiple-choice answers, and basic player information.",
        "details": "Create a dynamic route `/game/[gameId]`. The UI should show the player's photo and name. It will have a central area for the question text and three large, distinct buttons for answers A, B, and C. The UI should listen for Socket.IO events to update.",
        "testStrategy": "Use component tests to render the screen with mock question data. Manually test the layout and responsiveness to ensure buttons are large and accessible.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Dynamic Route and Page for Player Game Screen",
            "description": "Set up the file structure for the dynamic route `/game/[gameId]` within the Next.js App Router. Create the initial `app/game/[gameId]/page.tsx` file, mark it as a client component (`'use client'`), and implement logic to extract the `gameId` from the URL parameters.",
            "dependencies": [],
            "details": "Create a new folder structure `app/game/[gameId]`. The `page.tsx` file inside should be a functional component that uses the `useParams` hook from `next/navigation` to retrieve the game ID. This component will serve as the main container for the player's game interface.",
            "status": "pending",
            "testStrategy": "Navigate to a URL like `/game/123` and verify that the page component renders and can correctly log the `gameId` '123' to the console."
          },
          {
            "id": 2,
            "title": "Build Static UI Layout for Game Screen",
            "description": "Using `shadcn/ui` components and Tailwind CSS, create the static visual layout of the game screen. This includes a header for the player's avatar and name, a central card for the question text, and three large, distinct buttons for answers A, B, and C.",
            "dependencies": [
              "11.1"
            ],
            "details": "In `app/game/[gameId]/page.tsx`, use `Card`, `Button`, and `Avatar` components from `shadcn/ui`. Style the components according to the brutalist theme, ensuring the answer buttons are large and easily clickable on various devices. Use placeholder data for the player name, image, question, and answers for this static build.",
            "status": "pending",
            "testStrategy": "Render the component with mock data in a Storybook story or on the page itself. Visually inspect the layout to ensure it matches the design requirements and is responsive."
          },
          {
            "id": 3,
            "title": "Fetch and Display Initial Player Data",
            "description": "Implement a `useEffect` hook within the game screen page to fetch the participating player's data (e.g., name, photo URL) from an API endpoint upon page load. The fetched data should then be stored in component state and displayed in the UI.",
            "dependencies": [
              "11.2"
            ],
            "details": "Assume a player ID is stored in `localStorage` after registration (from Task 6). On component mount, make a `fetch` request to an API endpoint like `/api/participants/[participantId]`. Use the response to populate the state for the player's name and photo, which will update the `Avatar` and name display.",
            "status": "pending",
            "testStrategy": "Mock the API endpoint. Verify that the component calls the endpoint on load and correctly displays the mock player data. Test the loading state and handle potential fetch errors gracefully."
          },
          {
            "id": 4,
            "title": "Integrate Socket.IO Client and Connection Management",
            "description": "Install the `socket.io-client` library and create a custom hook or utility service to manage the WebSocket connection. This service should connect to the Socket.IO server on component mount and handle joining the correct game room.",
            "dependencies": [
              "11.1"
            ],
            "details": "Run `npm install socket.io-client`. Create a file, e.g., `lib/socket.ts`, to initialize the client. In the `page.tsx` component, use a `useEffect` hook to establish the connection and emit a 'joinGame' event with the `gameId`. Ensure the connection is properly closed when the component unmounts.",
            "status": "pending",
            "testStrategy": "Add console logs to verify that the client attempts to connect on component mount and disconnects on unmount. Check server-side logs to confirm that the 'joinGame' event is received with the correct `gameId`."
          },
          {
            "id": 5,
            "title": "Implement Real-time Event Handling for Questions and Answers",
            "description": "Use the established Socket.IO connection to listen for server-sent events like `newQuestion`. Update the component's state to display the received question and answer options. Implement `onClick` handlers for the answer buttons to emit a `submitAnswer` event back to the server.",
            "dependencies": [
              "11.2",
              "11.4"
            ],
            "details": "Within the `useEffect` hook that manages the socket connection, add listeners for game events. On a `newQuestion` event, update a state variable holding the current question object. The UI will re-render to show the new data. The `onClick` handler for each answer button should emit a `submitAnswer` event containing the `gameId`, player ID, and the selected answer ('A', 'B', or 'C').",
            "status": "pending",
            "testStrategy": "Use a mock Socket.IO server to emit `newQuestion` events and verify that the UI updates correctly. Click an answer button and verify that the corresponding `submitAnswer` event is emitted with the correct payload."
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement Real-time Game Event Synchronization",
        "description": "Use Socket.IO to synchronize the game state across all clients (players, admin, public display). This includes broadcasting new questions, round results, and final game outcomes.",
        "details": "The backend game logic (Task 10) will emit Socket.IO events like `game:start`, `question:new`, `round:end`, and `game:end`. The client-side components (Player Screen, Public Display) will subscribe to these events and update their UI accordingly.",
        "testStrategy": "Open multiple browser windows (simulating 3 players and a public display). Start a game from the admin panel and verify that all windows receive the events and update their state in sync.",
        "priority": "high",
        "dependencies": [
          10,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Enhance Backend Socket.IO Server for Game Room Management",
            "description": "Modify the existing Socket.IO server setup in `src/app/api/socket/route.ts` to handle game-specific rooms. Implement logic for clients to join a room based on their `gameId` upon connection.",
            "dependencies": [],
            "details": "On a new connection, the server should listen for a `client:join_game` event from the client, which must include the `gameId`. Use the `socket.join(gameId)` method to add the connecting client to the appropriate room. This is critical for ensuring that game events are broadcast only to the clients participating in that specific game session.",
            "status": "pending",
            "testStrategy": "Connect multiple clients using a test script or browser consoles. Have them emit `client:join_game` with the same `gameId`. Verify on the server logs that they are correctly added to the same room. Test that a broadcast to that room is not received by a client that joined a different room or no room."
          },
          {
            "id": 2,
            "title": "Implement Frontend Socket.IO Provider and `useSocket` Hook",
            "description": "Create a `SocketProvider` component that establishes and manages the connection to the Socket.IO server. This provider will use React Context to make the socket instance available throughout the application. A `useSocket` custom hook should be created for easy consumption of the context.",
            "dependencies": [
              "12.1"
            ],
            "details": "Create or modify `src/contexts/SocketContext.tsx` to initialize the socket connection using the client library. The `SocketProvider` should be wrapped around the root layout or relevant page layouts. The `useSocket` hook will provide a simple interface (`useContext(SocketContext)`) for components to access the socket instance. Upon establishing a connection, the client should automatically emit the `client:join_game` event, retrieving the `gameId` from the URL parameters.",
            "status": "pending",
            "testStrategy": "Wrap a test page with the `SocketProvider`. Use the `useSocket` hook within the page to get the socket instance and verify its `connected` property is true. Check the server logs to confirm the `client:join_game` event was received after the client connected."
          },
          {
            "id": 3,
            "title": "Integrate Socket.IO Emitters into Backend Game Service",
            "description": "Modify the backend game logic, likely located in `src/services/gameService.ts`, to broadcast events at key state changes by using the Socket.IO server instance.",
            "dependencies": [
              "12.1"
            ],
            "details": "The API routes that trigger game logic (e.g., starting a game, processing answers) have access to the `io` instance from the initial socket setup. This instance must be passed to the relevant functions in `gameService.ts`. Implement `io.to(gameId).emit('game:start', gameData)` in the `startGame` function, `io.to(gameId).emit('question:new', questionData)` in the `nextQuestion` function, and similarly for `round:end` and `game:end` events.",
            "status": "pending",
            "testStrategy": "Trigger a backend API call that starts a game. Verify that all clients connected to that game's room (from subtask 12.1) receive the `game:start` event with the correct payload. Repeat for other game logic functions and their corresponding events."
          },
          {
            "id": 4,
            "title": "Implement Client Listeners for In-Game Events (New Question, Round End)",
            "description": "In the primary game components (`/game/[gameId]/player/[playerId]/page.tsx` and `/display/[gameId]/page.tsx`), use the `useSocket` hook to listen for and react to `question:new` and `round:end` events.",
            "dependencies": [
              "12.2",
              "12.3"
            ],
            "details": "Within the Player and Public Display components, use a `useEffect` hook to register event listeners via the `useSocket` hook. On receiving a `question:new` event, update the component's state with the new question, options, and reset any timers. On `round:end`, update the UI to show round results, such as current scores and correct answer feedback.",
            "status": "pending",
            "testStrategy": "With multiple clients open on the player and display screens, trigger the backend logic to advance to a new question. Verify that all clients update their UI simultaneously to show the new question. Do the same for the end of a round, ensuring results are displayed correctly on all screens."
          },
          {
            "id": 5,
            "title": "Implement Client Listeners for Game State Transitions (Start, End)",
            "description": "Implement client-side listeners for the `game:start` and `game:end` events to manage high-level game flow, such as navigating users between a lobby, the game screen, and the final results page.",
            "dependencies": [
              "12.2",
              "12.3"
            ],
            "details": "In a pre-game or lobby component, listen for the `game:start` event. Upon receiving it, use the Next.js `useRouter` to programmatically navigate the user to their specific game screen (e.g., `/game/[gameId]/player/[playerId]`). In the main game components, listen for the `game:end` event. When this event is received, navigate the user to a final results or summary page, passing along any final game state data received in the event payload.",
            "status": "pending",
            "testStrategy": "Start a game from the admin panel. Verify that all player clients, initially on a waiting/lobby page, are automatically redirected to the game screen. At the end of the game, trigger the `game:end` event and verify all clients are navigated to the final scoreboard page."
          }
        ]
      },
      {
        "id": 13,
        "title": "Enable Answer Submission and Real-time Scoring",
        "description": "Allow players to submit their answers via the game screen. The server will process these answers, calculate scores, and broadcast updates in real-time.",
        "details": "On the player screen, clicking an answer button will emit an `answer:submit` event to the server with the `question_id` and chosen answer. The server will validate the answer, record the response time, calculate the score, save it to the `Answer` model, update the `GameParticipant` score, and broadcast the new scores to all clients.",
        "testStrategy": "Simulate multiple players answering a question. Verify that the first correct answer receives the highest points. Test edge cases like late answers (after the timer expires) and disconnections.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Client-Side `answer:submit` Event Emission",
            "description": "On the player game screen, add `onClick` handlers to the answer buttons. When a player clicks an answer, emit a `answer:submit` event via Socket.IO to the server. The event payload must include the `question_id` and the chosen answer (e.g., 'A', 'B', or 'C').",
            "dependencies": [],
            "details": "Locate the answer button components within the player game screen UI (likely in `src/app/game/[gameId]/page.tsx` or a child component). Use the existing client-side Socket.IO instance to emit the event. Ensure the component has access to the current question's ID to include in the payload.",
            "status": "pending",
            "testStrategy": "In the browser, join a game as a player. Use the browser's developer tools (Network tab) to confirm that clicking an answer button sends a `answer:submit` WebSocket message with the correct payload."
          },
          {
            "id": 2,
            "title": "Create Server-Side Listener for `answer:submit` Event",
            "description": "On the backend, create a new Socket.IO event listener for the `answer:submit` event. This handler will be the entry point for all incoming answers and should be structured to access the player's identity from their socket connection.",
            "dependencies": [
              "13.1"
            ],
            "details": "In the main Socket.IO configuration file (e.g., `src/app/api/socket/route.ts` or a dedicated handler module), add `socket.on('answer:submit', (data) => { ... });` within the `io.on('connection', ...)` block. The handler should initially parse the incoming data (`question_id`, `answer`) and identify the `gameParticipant` associated with the `socket.id`.",
            "status": "pending",
            "testStrategy": "Add a `console.log` inside the new server-side handler. Trigger the event from the client and verify that the server logs the received data and the correct socket ID."
          },
          {
            "id": 3,
            "title": "Develop Answer Validation and Score Calculation Logic",
            "description": "Within the `answer:submit` server-side handler, implement the logic to validate the answer and calculate the score. This involves fetching the correct answer for the question and calculating points based on correctness and the time taken to answer.",
            "dependencies": [
              "13.2"
            ],
            "details": "Retrieve the current question's data, including the correct answer and the time it was sent. Compare the player's answer to the correct one. Calculate the response time by subtracting the question's broadcast timestamp from the current time. Implement a scoring formula, for example: `score = isCorrect ? Math.max(0, 1000 - (responseTimeInMs / 10)) : 0`. Handle cases where the answer is late (submitted after the question's time limit).",
            "status": "pending",
            "testStrategy": "Write unit tests for the scoring function with various inputs: correct answer early, correct answer late, incorrect answer, and an answer submitted after the timer has expired."
          },
          {
            "id": 4,
            "title": "Persist Answer and Update Participant Score in Database",
            "description": "After validating the answer and calculating the score, use the Drizzle ORM to save the results to the database. This involves creating a new record in the `answers` table and updating the player's score in the `gameParticipants` table.",
            "dependencies": [
              "13.3"
            ],
            "details": "Using the Drizzle client, execute an `insert` operation on the `answers` table, saving the `gameParticipantId`, `questionId`, chosen answer, correctness, and response time. Then, execute an `update` operation on the `gameParticipants` table to atomically increment the `score` for the corresponding participant (`score = score + newPoints`). Ensure this is done only for the first valid answer from a participant for a given question.",
            "status": "pending",
            "testStrategy": "After a test answer is submitted, query the database directly to verify that a new row exists in the `answers` table with the correct data and that the `score` in the `gameParticipants` table has been updated correctly."
          },
          {
            "id": 5,
            "title": "Broadcast Real-time Score Updates to All Clients",
            "description": "Once the database has been updated, fetch the latest scores for all participants in the game and broadcast them to all clients in the game room. This ensures that all screens (player, public display, admin) are synchronized.",
            "dependencies": [
              "13.4"
            ],
            "details": "After the database transaction is complete, query the `gameParticipants` table to get a list of all participants and their updated scores for the current game. Emit a new event, such as `game:score_update`, to the game's room using `io.to(gameId).emit(...)`. The payload should be an array of participant objects with their names, IDs, and new scores.",
            "status": "pending",
            "testStrategy": "Open multiple browser windows (simulating different players and a public display). Submit an answer from one player and verify that all other windows receive the `game:score_update` event and that their displayed scores update in real-time."
          }
        ]
      },
      {
        "id": 14,
        "title": "Build Public Display Screen with Idle Mode Ranking",
        "description": "Create a public-facing screen that mirrors the live game action. When no game is in progress (idle mode), this screen should display a ranking of top players from previous games.",
        "details": "Create a page at `/display`. This page will connect to Socket.IO and render game events visually for the audience. When the game state is idle, it should fetch data from the `Game` and `GameParticipant` tables to calculate and display an all-time leaderboard.",
        "testStrategy": "Test the display during a live game to ensure it syncs with player actions. After a game ends, verify that the display switches to idle mode and shows the correct, updated ranking.",
        "priority": "medium",
        "dependencies": [
          10,
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Basic Page Structure for /display",
            "description": "Create the Next.js page route at `/display` using the App Router (`app/display/page.tsx`). Set up a basic, full-screen layout component that will serve as the container for both the live game view and the idle mode leaderboard. This initial component should have a distinct background and placeholder text.",
            "dependencies": [],
            "details": "Create the file `app/display/page.tsx`. The component should be a client component (`'use client'`) as it will need to use hooks for state management and socket connections later. Style it to take up the full viewport.",
            "status": "pending",
            "testStrategy": "Navigate to `/display` in the browser and verify that the new page renders with its basic layout and placeholder content, covering the entire screen."
          },
          {
            "id": 2,
            "title": "Create API Endpoint for All-Time Leaderboard Data",
            "description": "Implement a new API route at `/api/leaderboard`. This `GET` endpoint will use Prisma to query all `Game` records with a status of 'finished'. It will then aggregate the `score` from the `GameParticipant` table for each unique `Participant`, sort them in descending order, and return the top players (e.g., top 20) with their name, photo URL, and total aggregated score.",
            "dependencies": [],
            "details": "Create `app/api/leaderboard/route.ts`. Use Prisma's `groupBy` and `_sum` aggregation features on the `GameParticipant` model, joined with the `Participant` model to get names and photos. Ensure the query filters for games that are 'finished'.",
            "status": "pending",
            "testStrategy": "Manually add some test data for finished games and participants into the database. Access `/api/leaderboard` via a browser or API client and verify it returns a correctly structured JSON array of ranked players."
          },
          {
            "id": 3,
            "title": "Build UI Component for Idle Mode Leaderboard",
            "description": "Create a reusable React component, `LeaderboardDisplay.tsx`, that fetches data from the `/api/leaderboard` endpoint. The component should render a visually appealing ranked list of top players, showing their rank, photo, name, and total score. It should handle loading and error states gracefully.",
            "dependencies": [
              "14.2"
            ],
            "details": "Create `components/display/LeaderboardDisplay.tsx`. Use a client-side data fetching hook like `useSWR` or `useEffect` with `fetch` to get data from the API endpoint created in the previous subtask. Design the UI to be large and clear for public viewing from a distance.",
            "status": "pending",
            "testStrategy": "Render the component in Storybook or on a temporary page. Mock the API response to test the loading, success, and error states. Verify the layout is clean and readable."
          },
          {
            "id": 4,
            "title": "Integrate Socket.IO Client and Live Game State Management",
            "description": "On the `/display` page, implement the client-side logic to connect to the Socket.IO server. Create a custom hook (e.g., `useGameSocket`) to manage the connection, listen for key game events like `gameStateUpdate`, and store the current game state (e.g., 'idle', 'active', 'showing_question') and associated data in a React state.",
            "dependencies": [],
            "details": "In `app/display/page.tsx`, import the `socket.io-client` library. Establish the connection and register event listeners within a `useEffect` hook. The hook should manage the socket instance and expose the live game state to the page component. The initial state should default to 'idle'.",
            "status": "pending",
            "testStrategy": "With the server running, load the `/display` page and use browser developer tools to confirm a WebSocket connection is established. Manually emit a `gameStateUpdate` event from the server (or a test script) and verify the component's state updates accordingly using React DevTools."
          },
          {
            "id": 5,
            "title": "Implement Conditional Rendering for Live vs. Idle Modes",
            "description": "In the main component for the `/display` page, use the game state received from the Socket.IO connection to conditionally render the UI. If the game state is 'idle', display the `LeaderboardDisplay` component. Otherwise, render placeholder components for the live game view (e.g., a component to show the current question).",
            "dependencies": [
              "14.3",
              "14.4"
            ],
            "details": "In `app/display/page.tsx`, use the state from the `useGameSocket` hook. Implement a conditional (e.g., `if (gameState === 'idle') { ... } else { ... }`) to switch between rendering `<LeaderboardDisplay />` and a new `<LiveGameView />` placeholder component. This ties the idle and live states together.",
            "status": "pending",
            "testStrategy": "Run the application. Verify that the leaderboard is shown by default (initial 'idle' state). Manually emit a `gameStateUpdate` event from the server to change the state to 'active' and confirm the UI switches to the live game view placeholder. Emit another event to return to 'idle' and verify the leaderboard reappears."
          }
        ]
      },
      {
        "id": 15,
        "title": "Apply Dark Brutalist Theme and Basic Framer Motion Animations",
        "description": "Implement the visual identity of the application by applying a dark brutalist theme and adding initial animations for key user interactions.",
        "details": "Refine the Tailwind CSS configuration with a dark, high-contrast color palette, sharp edges, and bold typography. Integrate Framer Motion to add animations for page transitions, answer feedback (e.g., color flash on correct/incorrect), and score updates.",
        "testStrategy": "Visually inspect all screens to ensure the theme is applied consistently. Test animations for smoothness and performance. Gather user feedback on the visual impact and clarity of the UI.",
        "priority": "low",
        "dependencies": [
          11,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Dark Brutalist Theme in Tailwind CSS",
            "description": "Update `tailwind.config.ts` and `globals.css` to establish the dark brutalist visual identity, focusing on colors, borders, and typography.",
            "dependencies": [],
            "details": "In `tailwind.config.ts`, extend the theme to include a custom high-contrast color palette (e.g., `background: '#111111'`, `foreground: '#F5F5F5'`, `primary: '#FFFF00'`). Override the default `borderRadius` scale, setting all values to '0' to enforce sharp edges. In `globals.css`, apply the base background and foreground colors to the `body` element.",
            "status": "pending",
            "testStrategy": "Visually inspect the application's home page to confirm the dark background, high-contrast text, and absence of rounded corners on any default elements. Verify custom colors are available as Tailwind classes."
          },
          {
            "id": 2,
            "title": "Install Framer Motion and Create Page Transition Provider",
            "description": "Add `framer-motion` as a project dependency and create a client-side provider component to enable animated page transitions across the app.",
            "dependencies": [],
            "details": "Run `npm install framer-motion`. Create a new client component `src/components/providers/AnimationProvider.tsx`. This component will use `AnimatePresence` to wrap its children, configured with `mode='wait'` to ensure smooth transitions. This provider will be used in the root layout.",
            "status": "pending",
            "testStrategy": "After installation, run the development server to ensure no build errors occur. The `AnimationProvider` component should render its children without any visual changes yet."
          },
          {
            "id": 3,
            "title": "Implement Page Transition Animation in Root Layout",
            "description": "Integrate the `AnimationProvider` into the root layout and apply a basic fade animation to content as users navigate between pages.",
            "dependencies": [
              "15.2"
            ],
            "details": "In `src/app/layout.tsx`, import and wrap the page `{children}` with the `AnimationProvider`. Inside the layout, wrap the children with a `motion.main` element that defines `initial`, `animate`, and `exit` variants for a simple fade-in/fade-out effect (e.g., `opacity: 0` to `opacity: 1`).",
            "status": "pending",
            "testStrategy": "Navigate between two or more test pages and verify that the content of the old page fades out before the new page's content fades in. The animation should be smooth."
          },
          {
            "id": 4,
            "title": "Create Animated Feedback for Answer Selection",
            "description": "Develop a Framer Motion animation to provide immediate visual feedback on answer buttons when a user makes a selection.",
            "dependencies": [
              "15.1",
              "15.2"
            ],
            "details": "For the component that renders answer options (e.g., a `Button` in the Player screen), convert it to a `motion.button`. Use the `whileTap` prop for a simple scale effect. Additionally, trigger a variant-based animation based on a `isCorrect` or `isIncorrect` prop. The 'correct' variant will flash a green background, and the 'incorrect' variant will flash a red background and apply a slight side-to-side shake animation.",
            "status": "pending",
            "testStrategy": "On a test page, create buttons that simulate correct and incorrect answer states. Clicking them should trigger the corresponding color flash and/or shake animation as defined."
          },
          {
            "id": 5,
            "title": "Animate Score Updates Using Framer Motion",
            "description": "Add a dynamic animation to the score display element to draw attention to score changes.",
            "dependencies": [
              "15.1",
              "15.2"
            ],
            "details": "Locate the component responsible for displaying the player's score. Wrap the numerical score value in a `motion.span`. Use the `key` prop on this span, setting it to the score value itself. This will cause Framer Motion to re-render and animate the element on change. Define `initial`, `animate`, and `exit` props to create a quick 'pop' or 'flip' effect as the old score number is replaced by the new one.",
            "status": "pending",
            "testStrategy": "Create a test component with a button that increments a score state variable. Verify that each time the score updates, the number animates smoothly, for example, by scaling up and fading in."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-25T15:05:54.002Z",
      "updated": "2025-09-25T20:36:29.057Z",
      "description": "Tasks for master context"
    }
  }
}